// Generated by CoffeeScript 1.9.3
var Backbone, SockData, StreamCollection,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

console.log("window: " + window);

if (!((window.Backbone != null) && (typeof exports !== "undefined" && exports !== null))) {
  Backbone = require('backbone');
}

SockData = require('./sockdata');

StreamCollection = (function(superClass) {
  extend(StreamCollection, superClass);

  function StreamCollection() {
    return StreamCollection.__super__.constructor.apply(this, arguments);
  }

  StreamCollection.prototype.model = SockData;

  StreamCollection.prototype.fetch = function() {
    console.log("SockData::fetch is not allowed");
    return false;
  };

  StreamCollection.prototype.sync = function() {
    console.log("SockData::sync is not allowed");
    return false;
  };

  StreamCollection.prototype._prepareModel = function(attrs, options) {
    var model;
    if (attrs instanceof Backbone.Model) {
      if (!attrs.collection) {
        attrs.collection = this;
      }
      return attrs;
    }
    options = options ? _.clone(options) : {};
    options.collection = this;
    model = new this.model(attrs.body, options);
    model.header = Object.freeze(attrs.header);
    if (!model.validationError) {
      return model;
    }
    this.trigger('invalid', this, model.validationError, options);
    return false;
  };

  StreamCollection.prototype.send = function(data) {
    return this.create(data);
  };

  StreamCollection.prototype.initialize = function() {
    var _client;
    if (arguments[0] instanceof WebSock.Client) {
      return _client = arguments[0];
    }
  };

  return StreamCollection;

})(Backbone.Collection);

module.exports = StreamCollection;
