// Generated by CoffeeScript 1.9.3
var Backbone, EventEmitter, SocketIOConnection, ValidationModel,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EventEmitter = require('events').EventEmitter;

if (!((window.Backbone != null) && (typeof exports !== "undefined" && exports !== null))) {
  Backbone = require('backbone');
}

ValidationModel = (function(superClass) {
  extend(ValidationModel, superClass);

  function ValidationModel() {
    return ValidationModel.__super__.constructor.apply(this, arguments);
  }

  ValidationModel.prototype.defaults = {
    header: {
      sender_id: String,
      type: String,
      sntTime: Date,
      srvTime: Date,
      rcvTime: Date,
      size: Number
    },
    body: null
  };

  ValidationModel.prototype.validate = function(o) {
    var i, key, len, ref;
    if (o == null) {
      o = this.attributes;
    }
    if (o.header == null) {
      return "required part 'header' was not defined";
    }
    ref = this.defaults.header;
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      if (o.header[key] == null) {
        return "required header " + key + " was not defined";
      }
    }
    if (typeof o.header.sender_id !== 'string') {
      return "wrong value for sender_id header";
    }
    if (typeof o.header.type !== 'string') {
      return "wrong value for type header";
    }
    if ((new Date(o.header.sntTime)).getTime() !== o.header.sntTime) {
      return "wrong value for sntTime header";
    }
    if ((new Date(o.header.srvTime)).getTime() !== o.header.srvTime) {
      return "wrong value for srvTime header";
    }
    if ((new Date(o.header.rcvTime)).getTime() !== o.header.rcvTime) {
      return "wrong value for rcvTime header";
    }
    if (!o.body) {
      return "required part 'body' was not defined";
    }
    if (!JSON.stringify(o.body === o.size)) {
      return "content size was invalid";
    }
  };

  return ValidationModel;

})(Backbone.Model);

SocketIOConnection = (function(superClass) {
  extend(SocketIOConnection, superClass);

  SocketIOConnection.prototype.defaults = {
    host: 'localhost',
    port: 80,
    multiplex: true,
    reconnection: true,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    timeout: 20000
  };

  function SocketIOConnection(__options) {
    var _socket, opts;
    this.__options = __options;
    opts = _.extend({}, this.defaults, _.pick(this.__options, _.keys(this.defaults)));
    _socket = io("" + this.__addr, opts).on('ws:datagram', (function(_this) {
      return function(data) {
        var dM, stream;
        data.header.rcvTime = Date.now();
        (dM = new _this.validator).set(data);
        if (dM.isValid() && ((stream = _this.__streamHandlers[dM.attributes.header.type]) != null)) {
          return stream.add(dM.attributes);
        }
      };
    })(this)).on('connect', (function(_this) {
      return function() {
        module.parent.WebSock.SockData.__connection__ = _this;
        return _this.trigger('connect', _this);
      };
    })(this)).on('disconnect', (function(_this) {
      return function() {
        return _this.trigger('disconnect');
      };
    })(this)).on('reconnect', (function(_this) {
      return function() {
        return _this.trigger('reconnect');
      };
    })(this)).on('reconnecting', (function(_this) {
      return function() {
        return _this.trigger('reconnecting', _this);
      };
    })(this)).on('reconnect_attempt', (function(_this) {
      return function() {
        return _this.trigger('reconnect_attempt', _this);
      };
    })(this)).on('reconnect_error', (function(_this) {
      return function() {
        return _this.trigger('reconnect_error', _this);
      };
    })(this)).on('reconnect_failed', (function(_this) {
      return function() {
        return _this.trigger('reconnect_failed', _this);
      };
    })(this)).on('error', (function(_this) {
      return function() {
        return _this.trigger('error', _this);
      };
    })(this));
    this.getSocket = (function(_this) {
      return function() {
        return _socket;
      };
    })(this);
  }

  return SocketIOConnection;

})(EventEmitter);

SocketIOConnection.prototype.validator = ValidationModel;

module.exports = SocketIOConnection;
