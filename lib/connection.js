// Generated by CoffeeScript 1.9.0
var EventEmitter, SocketIOConnection, ValidationModel,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __hasProp = {}.hasOwnProperty;

EventEmitter = require('events').EventEmitter;

ValidationModel = (function(_super) {
  __extends(ValidationModel, _super);

  function ValidationModel() {
    return ValidationModel.__super__.constructor.apply(this, arguments);
  }

  ValidationModel.prototype.defaults = {
    header: {
      sender_id: String,
      type: String,
      sntTime: Date,
      srvTime: Date,
      rcvTime: Date,
      size: Number
    },
    body: null
  };

  ValidationModel.prototype.validate = function(o) {
    var key, _i, _len, _ref;
    if (o == null) {
      o = this.attributes;
    }
    if (o.header == null) {
      return "required part 'header' was not defined";
    }
    _ref = this.defaults.header;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      if (o.header[key] == null) {
        return "required header " + key + " was not defined";
      }
    }
    if (typeof o.header.sender_id !== 'string') {
      return "wrong value for sender_id header";
    }
    if (typeof o.header.type !== 'string') {
      return "wrong value for type header";
    }
    if ((new Date(o.header.sntTime)).getTime() !== o.header.sntTime) {
      return "wrong value for sntTime header";
    }
    if ((new Date(o.header.srvTime)).getTime() !== o.header.srvTime) {
      return "wrong value for srvTime header";
    }
    if ((new Date(o.header.rcvTime)).getTime() !== o.header.rcvTime) {
      return "wrong value for rcvTime header";
    }
    if (!o.body) {
      return "required part 'body' was not defined";
    }
    if (!JSON.stringify(o.body === o.size)) {
      return "content size was invalid";
    }
  };

  return ValidationModel;

})(Backbone.Model);

SocketIOConnection = (function(_super) {
  __extends(SocketIOConnection, _super);

  function SocketIOConnection(host, port, _at___options) {
    var opts, _socket;
    this.__options = _at___options;
    opts = {
      multiplex: true,
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      timeout: 20000
    };
    _.extend(opts, _.pick(this.__options, _.keys(opts)));
    _socket = io("" + this.__addr, opts).on('ws:datagram', (function(_this) {
      return function(data) {
        var dM, stream;
        data.header.rcvTime = Date.now();
        (dM = new ValidationModel).set(data);
        if (dM.isValid() && ((stream = _this.__streamHandlers[dM.attributes.header.type]) != null)) {
          return stream.add(dM.attributes);
        }
      };
    })(this)).on('connect', (function(_this) {
      return function() {
        WebSock.SockData.__connection__ = _this;
        return _this.trigger('connect', _this);
      };
    })(this)).on('disconnect', (function(_this) {
      return function() {
        return _this.trigger('disconnect');
      };
    })(this)).on('reconnect', (function(_this) {
      return function() {
        return _this.trigger('reconnect');
      };
    })(this)).on('reconnecting', (function(_this) {
      return function() {
        return _this.trigger('reconnecting', _this);
      };
    })(this)).on('reconnect_attempt', (function(_this) {
      return function() {
        return _this.trigger('reconnect_attempt', _this);
      };
    })(this)).on('reconnect_error', (function(_this) {
      return function() {
        return _this.trigger('reconnect_error', _this);
      };
    })(this)).on('reconnect_failed', (function(_this) {
      return function() {
        return _this.trigger('reconnect_failed', _this);
      };
    })(this)).on('error', (function(_this) {
      return function() {
        return _this.trigger('error', _this);
      };
    })(this));
    this.getSocket = (function(_this) {
      return function() {
        return _socket;
      };
    })(this);
  }

  return SocketIOConnection;

})(EventEmitter);
